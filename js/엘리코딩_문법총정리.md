# JS 기초 강의 (ES5+)

> ‘use strict’;
: 문법을 확실하게 하지 않으면 코드 인정x
> 

## HTML에서 JS를 불러오는 방법

---

### 1. head + defer ⇒ best!

<img width="1110" alt="Untitled (3)" src="https://user-images.githubusercontent.com/82459123/160081041-272cdc15-369f-49b1-9cbc-e2074251a6b7.png">


```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Document</title>
		<script defer src="main.js"></script>
	</head>
	<body>
		<div></div>
	</body>
</html>
```

- 사용자에게 html 페이지를 보여준 다음 js 바로 실행
- js 순서대로 실행

### 2. head + async

<img width="1147" alt="Untitled (4)" src="https://user-images.githubusercontent.com/82459123/160081061-b2d06499-04f7-4e5a-aaab-652743464f01.png">



```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Document</title>
		<script async src="main.js"></script>
	</head>
	<body>
		<div></div>
	</body>
</html>
```

1. 병렬로 js 다운로드 명령
2. js 실행
3. 나머지 html 실행

- 다운로드 시간 절약
- 원하는 시점에 html이 정립되지 않을 수 있음
- 여러개 js라면 가장 먼저 fetching되는거부터 실행

## 변수 개념

---

### scope

- global
    - 전역변수
- block
    - {} 안에 있는 변수
    

### var 쓰면 안되는 이유

- 값을 정의, 할당하기도 전에 값을 출력할 수 있음
- block scope이 없음 (block 무시하고 밖에서도 호출됨)

### let (read & write)

- 변수 선언, 값 변경 O (mutable 데이터타입)
- `let maxNumber = 10;`

### Constants (read only)

- 한 번 선언하면, 값 변경 X (immutable 데이터타입)
- `const maxNumber = 10;`
- favor immutable data type always = 가능하면 변수 선언할 때 변경 안되는 걸로 해라
    - security
    - thread safety
    - reduce human mistakes
    

## 데이터타입 (variable types)

---

### 1. primitive - 더 이상 나눠질 수 없는

- number
    - number이라고 하지 않아도, `let a = 12;`
    - **Infinity, -Infinity, NaN**
        
        ```jsx
        //1.Infinity
        const infinity = 1/0;
        => Infinity
        
        //2.-Infinity
        const negativeInfinity = -1/0;
        => -Infinity
        
        //3.Not a number
        const nAn = 'not'/2;
        => NaN
        ```
        
- string
    
    ```jsx
    //방법1
    const jiwon = "jiwon";
    const helloJiwon = "hello" + jiwon;
    => hello jiwon
    
    //방법2 - template literals
    const jiwon = "jiwon";
    const helloJiwon = `hello ${jiwon}!`;
    => helloi jiwon
    ```
    
- boolean
    - false : 0, null, undefined, NaN, ‘’
    - true : false를 제외한 값들
- null
    - 비어있는 값이라고 할당이 되어 있는 상태
- undefined
    - 선언은 되었지만, 아무것도 정해지지 않은 상태
- symbol
    - 고유한 식별자를 주고 싶을 때 사용
    - 우선순위를 주고 싶을 때 사용
    
    ```jsx
    const symbol1 = Symbol('id');
    const symbol2 = Symbol('id');
    console.log(symbol1 === symbol2);
    => false
    
    const gSymbol1 = Symbol.for('id');
    const gSymbol2 = Symbol.for('id');
    console.log(gSymbol1 === gSymbol2);
    => true
    
    =>string으로 변환해서 출력해야 함
    ```
    

### 2. object - single item 여러 개

- box container

```jsx
const jiwon = { name:'jiwon', age:24};
jiwon.age = 23; -> 이런 식으로 변경 가능
```

- const로 지정되어 있어 변경 불가
- jiwon  object 안에는 name과 age가 지정되어 있음

### 3. function

## Dynamic typing

---

- 할당된 값에 따라서 타입이 변할 수 있는 것
- 런타임에서 타입이 변하기 때문에 에러가 많이 남
    
    ⇒ 이거 때문에 Typesrcipt 배움
    

## 연산, 반복문

---

### 1. String concatenation

```jsx
console.log('my' + 'cat');
console.log('1'+2);
console.log(`string literals: 1+2 = ${1+2}`);
=> my cat
	 12
	 string literals: 1+2 = 3
```

### 2. Numeric operators

```jsx
console.log(1+1); //add-더하기
console.log(1-1); //substract-빼기
console.log(1/1); //divide-나누기
console.log(1*1); //multiply-곱하기
console.log(5%2); //remainder-나머지
console.log(2**3); //exponentiation-제곱, 승
```

### 3. Increment and decrement operators

```jsx
let counter = 2;
const preIncrement = ++counter;
	//counter = counter + 1;
	//preIncrement = counter;

const postIncrement = counter++;
	//postIncrement = counter;
	//counter = counter + 1;
```

### 4. Assignment operators

`+=, -=, *=, /=`

### 5. Comparison operators

`<, >` 

### 6. Logical operators

- `||`(or) : 하나라도 True이면 True
    - 첫 번째 나온 값이 True이면 그 자리에서 출력해버림 → 뒤에 보지도 않음, 함수 호출하는 가벼운 변수를 앞에 둘 것
- `&&` (and) : 모두 True여야 True
- `!`(not) : 값을 True → False, False → True로 바꿔줌

### 7. Equality operators

- `==` (loose equality, with type conversion | 타입 달라도 값이 같으면 같음)
- `===` (strict equality, no type conversion | 타입이 다르면 값이 같아도 다름)

```jsx
const stringFive = '5';
const numberFive = 5;

//==
console.log(stringFive == numberFive);
console.log(stringFive != numberFive);
=> true
	 false

//===
console.log(stringFive === numberFive);
console.log(stringFive !== numberFive);
=> false
	 true

//object equality by reference
const jiwon1 = {name:'jiwon'};
const jiwon2 = {name:'jiwon'};
const jiwon3 = jiwon1;

console.log(jiwon1 == jiwon2);
console.log(jiwon1 === jiwon2);
console.log(jiwon1 === jiwon3);
=> false
	 false
	 true

//equality - puzzler
console.log(0 == false);
=> true
console.log(0 === false);
=> false (0은 불리언 타입이 아니기 때문에)
console.log('' == false);
=> true
console.log('' === false);
=> false (''은 불리언 타입이 아니기 때문)
console.log(null == undefined);
=> true (특이점)
console.log(null === undefined);
=> false
```

### 8. If operators

- if, else if, else

### 9. ? operator (ternary operator)

- `condition ? value1 : value2;`
- 간단할 때 사용

```jsx
console.log(name === 'jiwon' ? 'yes' : 'no');
-> true면 yes를 false면 no를
```

### 10. switch operators

- switch() case1, case2,,,

```jsx
const browser = 'IE';
switch (browser) {
	case 'IE':
		console.log('go away!');
		break;
	case 'Chrome':
	case 'Firefox':
		console.log('love you!');
		break;
	default:
		console.log('same all!');
		break;
}
```

### 11. while loop

```jsx
let i = 3;
while(i>0){
	console.log(`while: ${i}`);
	i--;
}
```

### 12. do-while loop

- do 안에 있는 것은 조건에 맞지 않더라도 무조건 한 번 실행 → while문

```jsx
do {
	console.log(`do while: ${i}`):
	i--;
} while (i>0);
```

### 13. for loop

- `for(begin; condition; step)`

```jsx
for (let i=3; i>0; i--){
	console.log(`for: ${i}`);
}
```

### 14. nested loop (중첩문)

```jsx
for (let i=0; i<20; i++) {
	for (let j=0; j<10; j++) {
		console.log(`i:${i}, j:${j}`);
	}
}
```

## Function

---

- js에서는 function도 object이기 때문에 변수로 할당 가능
- fundamental building block in the program
- subprogram can be used multiple items
    - 서브프로그램이라 불리며 재사용이 가능
- performs a task or calculates a value
    - ***한 가지***의 task나 값을 계산하기 위해 사용

```jsx
 "use strict";
function log(message) {
	console.log(message);
	return 0; 
}
```

- 바로 변수에 할당하는 것도 가능

```jsx
const print = function (){ //print 변수에 익명의 함수를 할당
	console.log('print');
};
print(); //print가 출력됨
const printAgain = print;
printAgain(); //print가 출력됨
```

### Parameters

---

- **premitive** parameters - value를 전달
- **object** parameters - reference(위치)를 전달

```jsx
function changeName(obj){
	//obj.name을 coder로 바꿔주는 함수
	obj.name = 'coder';
}
const jiwon = {name:'jiwon'};
changeName(jiwon);
console.log(jiwon);
=> {name:'coder'}
```

- **default** parameters (added in ES6)

```jsx
//from 옆에 원하는 문자열을 넣어서 default 값으로 표현 가능
function showMessage(message, from="unknown") {
	console.log(`${message} by ${from}`);
}
showMessage('Hi!');
=>Hi! by unknown
```

- **rest** parameters (added in ES6)

```jsx
	//...변수 -> 배열 형태로 저장됨
function printAll(...args){
	//1번 방법
	for(let i=0; i<args.length; i++){
		console.log(args[i]);
	}
	//2번 방법
	for(const arg of args){
		console.log(arg);
	}
}
printAll('jeong','jiwon','leon');
=>jeong
	jiwon
	leon
```

## Scope

---

> 밖에서는 안이 보이지 않고, 안에서만 밖을 볼 수 있다.
> 
- global 변수는 block안에서 호출 가능, but local 변수는 block 밖에서 호출 불가능

❗현업꿀팁❗

- 조건에 맞지 않은 경우 early return을 해서 값이 빨리 나오도록 해라

```jsx
function upgradeUser(user){
	if(user.point <= 10){
		return;
	}
}
```

## Callback

---

```jsx
function random(매개변수, 함수가 맞으면, 함수가 틀리면)
```

## Arrow function

---

> always ‘**anonymous function**’
> 

## Class

---

- **속성 (field)** | name, age
- **행동 (method)** | speak()

```jsx
class person {
	name;
	age;
	speak();
}
```

### Class vs Object

: 붕어빵 틀인 class에 재료를 넣으면 object

### class

> -template : 데이터x 틀만 정의해놓는 것
-declare once : 한 번만 선언
-no data in
> 

### object

> -instance of a class : 새로운 인스턴스 생성
-created many times
-data in
> 

1. **class declarations (class 선언)**

```jsx
1. class 선언

class Person {
	//constructor : 생성자
	//object 만들때 필요한 데이터를 전달
	constructor(name,age){
		//fields : 속성
		this.name = name;
		this.age = age;
	}

	//methods
	speak(){
		console.log(`${this.name}: hello!`);
	}
}

2. object 생성

//새로운 object 생성할 때는 new 사용
//class에는 (name, age)가 들어가야 함으로
const jiwon = new person('jiwon', 24);
console.log(jiwon.name);
console.log(jiwon.age);
jiwon.speak();
=> jiwon
	 24
	 jiwon: hello!
```

1. **Getter and Setters**
- get : 값 return
- set : 값 설정

- getter와 setter의 변수명을 class와 다르게 해야 하는 이유
    1. this.age 하면 바로 age를 불러오는 게 아니라, getter를 불러옴
    2. setter를 호출하는 순간 바로 메모리에 값을 할당하는 게 아니라 값을 setter-value에 전달하고 value를 this.age에 할당할 때, 다시 setter를 호출함
    
    (setter 내에서 value호출-setter호출 무한반복)
    

```jsx
class User {
	constructor(firstName, lastName, age){
		this.firstName = firstName;
		this.lastName = lastName;
		this.age = age;
	}

	get age() {
		return this._age;
	}

	set age(value) {
		//age값이 음수일 경우 
		//1번 방법
		if (value < 0) {
			throw Error('age can not bre nagative');
		}
		//2번 방법
		this._age = value < 0 ? 0 : value;
	}
}

const user1 = new User('Steve','Job',-1);
-> 나이가 음수가 될 수 없는데도 불구하고 -1이 출력될 수 있음 
-> 이럴 때 getter, setter 사용
```

1. **Fields (public, private)**

```jsx
class Experiment {
	//public으로 외부 접근 가능
	publicField = 2;
	//private으로 외부 접근 불가능
	#privateField = 0;
}
const experiment = new Experiment();
console.log(experiment.publicField);
console.log(experiment.privateField);
=> 2
	 undefined
```

1. **Static**

```jsx

```

1. **Inheritance (상속)**

```jsx
class Shape {
	constructor(width, height, color) {
		this.width = width;
		this.height = height;
		this.color = color;
	}

	draw() {
		console.og(`drawing ${this.color} color of`);
	}

	getArea() {
		return width * this.height;
	}
}

//상속
//extends라는 걸 이용하면 class Rextangle이 class Shape 속성까지 포함함
class Rectangle extends Shape {};
class Triangle extends Shape {
	//상위 class Shape에서 원하는 부분만 바꾸기 - 오버라이딩
	getArea() {
		return (this.width * this.height) / 2;
	}
};
const rectangle = new Rectangle(20,20,'blue');
rectangle.draw();
=> drawing blue color of
```

1. **Class checking : instanceOf**
- 해당 class의 instance인지 확인
- `command + 클릭` 으로 확인하기

```jsx
console.log(rectangle instanceof Rectangle); => true
console.log(triangle instanceof Shape); => true
console.log(triangle instanceof Object); => true
```

## Object

---